{"remainingRequest":"/opt/projects/daedal-wasm/static/node_modules/babel-loader/lib/index.js!/opt/projects/daedal-wasm/static/node_modules/vue-loader/lib/selector.js?type=script&index=0!/opt/projects/daedal-wasm/static/src/Mandelbrot.vue","dependencies":[{"path":"/opt/projects/daedal-wasm/static/src/Mandelbrot.vue","mtime":1643899500875},{"path":"/opt/projects/daedal-wasm/static/node_modules/cache-loader/dist/cjs.js","mtime":1643899499475},{"path":"/opt/projects/daedal-wasm/static/node_modules/babel-loader/lib/index.js","mtime":1643899499935},{"path":"/opt/projects/daedal-wasm/static/node_modules/vue-loader/lib/selector.js","mtime":1643899499219}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nconst R1 = [-2.0, -1.0];\nconst R2 = [1.0, 1.0];\nconst ITERATIONS = 100;\nexport default {\n  props: {\n    width: {\n      type: Number,\n      default: 640\n    },\n    height: {\n      type: Number,\n      default: 500\n    }\n  },\n\n  data() {\n    return {\n      renderTime: 0,\n      startPoint: null,\n      r1: R1,\n      r2: R2\n    };\n  },\n\n  mounted() {\n    this.renderMandelbrot();\n    document.addEventListener('keypress', this.onKeyPress);\n  },\n\n  beforeDestroy() {\n    document.removeEventListener('keypress', this.onKeyPress);\n  },\n\n  methods: {\n    getTarget() {\n      return this.$refs.container;\n    },\n\n    onMouseDown(evt) {\n      this._dragRectContext = this.$refs.dragRect.getContext('2d');\n      this._rect = this.$refs.container.getBoundingClientRect();\n      let x = evt.clientX - this._rect.left;\n      let y = evt.clientY - this._rect.top;\n      this.startPoint = [x, y];\n    },\n\n    onMouseMove(evt) {\n      if (this.startPoint) {\n        let rect = this._rect;\n        let x = evt.clientX - rect.left;\n        let y = evt.clientY - rect.top;\n        this.endPoint = [x, y];\n        this.updateDragRect(this.startPoint, [x, y]);\n      }\n    },\n\n    onMouseUp(evt) {\n      this.updateDragRect();\n\n      if (this.startPoint && this.endPoint) {\n        let [x0, y0] = this.startPoint,\n            [x1, y1] = this.endPoint;\n        let topLeftX = Math.min(x0, x1),\n            topLeftY = Math.min(y0, y1),\n            bottomRightX = Math.max(x0, x1),\n            bottomRightY = Math.max(y0, y1);\n        let r1 = pixel2Point(topLeftX, topLeftY, [this.width, this.height], this.r1, this.r2);\n        let r2 = pixel2Point(bottomRightX, bottomRightY, [this.width, this.height], this.r1, this.r2);\n        this.r1 = r1;\n        this.r2 = r2;\n        this.renderMandelbrot();\n      }\n\n      this.startPoint = null;\n      this.endPoint = null;\n      this._dragRectContext = null;\n    },\n\n    onKeyPress(evt) {\n      if (evt.key == ' ' && !v_eq(this.r1, this.r2)) {\n        this.r1 = R1;\n        this.r2 = R2;\n        this.renderMandelbrot();\n      }\n    },\n\n    updateDragRect(startPoint, endPoint) {\n      let ctx = this._dragRectContext;\n      ctx.clearRect(0, 0, this.width, this.height);\n\n      if (startPoint && endPoint) {\n        let [x0, y0] = startPoint;\n        let [x1, y1] = endPoint;\n        ctx.strokeStyle = '#00ff00';\n        ctx.strokeRect(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x0 - x1), Math.abs(y0 - y1));\n      }\n    },\n\n    renderMandelbrot() {\n      let ctx = this.$refs.canvas.getContext('2d');\n      let t0 = performance.now();\n      let imgData = ctx.createImageData(this.width, this.height);\n      let {\n        data\n      } = imgData;\n\n      for (let i = 0; i < this.width; i++) {\n        for (let j = 0; j < this.height; j++) {\n          let p = i * 4 + j * 4 * this.width;\n          let point = pixel2Point(i, j, [this.width, this.height], this.r1, this.r2);\n          let v = escapeTime(point, ITERATIONS);\n\n          if (v != -1) {\n            v = 255 - v;\n          } else {\n            v = 0;\n          }\n\n          data[p] = v;\n          data[p + 1] = v;\n          data[p + 2] = v;\n          data[p + 3] = 255;\n        }\n      }\n\n      ctx.putImageData(imgData, 0, 0);\n      this.renderTime = performance.now() - t0;\n    }\n\n  }\n};\n\nfunction v_eq(v1, v2) {\n  return v1 && v2 && v1[0] == v2[0] && v1[1] == v2[1];\n}\n\nfunction pixel2Point(x, y, bounds, topLeft, bottomRight) {\n  let [width, height] = [bottomRight[0] - topLeft[0], topLeft[1] - bottomRight[1]];\n  return [topLeft[0] + x * width / bounds[0], topLeft[1] - y * height / bounds[1]];\n}\n\nfunction escapeTime(c, limit) {\n  let za = 0.0,\n      zb = 0.0;\n\n  for (let i = 0; i < limit; i++) {\n    let zax = za * za - zb * zb + c[0];\n    let zbx = 2 * za * zb + c[1];\n    za = zax;\n    zb = zbx;\n\n    if (za * za + zb * zb > 4.0) {\n      return i;\n    }\n  }\n\n  return -1;\n}",{"version":3,"sources":["Mandelbrot.vue"],"names":[],"mappings":";;;;;;;;;;;;AAcA;AACA;AACA;AAEA;;;YAIA;eACA,AACA;AAHA;;YAKA;eACA,AACA,AACA;AAJA;AALA;;SAUA;;kBAEA;kBACA;UACA;UACA,AACA;AALA;AAMA;;YACA;SACA;+CACA;AACA;;kBACA;kDACA;AACA;;;gBAEA;wBACA;AACA;;qBACA;6DACA;wCACA;uCACA;uCACA;4BACA;AACA;;qBACA;2BACA;wBACA;mCACA;mCACA;4BACA;iDACA;AACA;AACA;;mBACA;WACA;;4CACA;4BACA;4BAEA;oCACA;oCACA;wCACA;wCAEA;0FACA;kGACA;kBACA;kBACA;aACA;AACA;;wBACA;sBACA;8BACA;AACA;;oBACA;qDACA;kBACA;kBACA;aACA;AACA;AACA;;yCACA;qBACA;2CACA;;kCACA;uBACA;uBACA;0BACA;4FACA;AACA;AACA;;uBACA;6CACA;2BACA;yDACA;;;UACA;;2CACA;8CACA;uCACA;iFACA;oCACA;;uBACA;sBACA;iBACA;gBACA;AACA;;oBACA;wBACA;wBACA;wBACA;AACA;AAEA;;mCACA;4CACA;AACA,AACA;;AAnFA;AA1BA;;AA+GA,sBACA;mDACA;;;AAEA,yDAEA;kDACA,6BACA;SACA,iCACA,qCACA,AACA;;;AAEA,8BACA;WACA;WACA;;kCACA;oCACA;8BACA;SACA;SACA;;iCACA;aACA;AACA;AACA;;UACA","file":"Mandelbrot.vue","sourceRoot":"src","sourcesContent":["<template>\n  <div class=\"container\" :style=\"{width: width + 'px', height: height + 'px'}\"\n      @mousedown=\"onMouseDown\"\n      @mousemove=\"onMouseMove\"\n      @mouseup=\"onMouseUp\"\n      ref=\"container\">\n    <h1 v-if=\"renderTime != 0\">{{ renderTime.toFixed(3) }} ms</h1>\n    <canvas :width=\"width\" :height=\"height\" ref=\"canvas\"></canvas>\n    <canvas :width=\"width\" :height=\"height\" ref=\"dragRect\"></canvas>\n  </div>\n</template>\n\n<script>\n\nconst R1 = [-2.0, -1.0];\nconst R2 = [1.0, 1.0];\nconst ITERATIONS = 100;\n\nexport default {\n  props: {\n    width: {\n      type: Number,\n      default: 640,\n    },\n    height: {\n      type: Number,\n      default: 500,\n    },\n  },\n  data() {\n    return {\n      renderTime: 0,\n      startPoint: null,\n      r1: R1,\n      r2: R2,\n    };\n  },\n  mounted() {\n    this.renderMandelbrot();\n    document.addEventListener('keypress', this.onKeyPress);\n  },\n  beforeDestroy() {\n    document.removeEventListener('keypress', this.onKeyPress);\n  },\n  methods: {\n    getTarget() {\n      return this.$refs.container;\n    },\n    onMouseDown(evt) {\n      this._dragRectContext = this.$refs.dragRect.getContext('2d');\n      this._rect = this.$refs.container.getBoundingClientRect();\n      let x = evt.clientX - this._rect.left;\n      let y = evt.clientY - this._rect.top\n      this.startPoint = [x, y];\n    },\n    onMouseMove(evt) {\n      if (this.startPoint) {\n        let rect = this._rect;\n        let x = evt.clientX - rect.left;\n        let y = evt.clientY - rect.top\n        this.endPoint = [x, y];\n        this.updateDragRect(this.startPoint, [x, y]);\n      }\n    },\n    onMouseUp(evt) {\n      this.updateDragRect();\n      if (this.startPoint && this.endPoint) {\n        let [x0, y0] = this.startPoint,\n            [x1, y1] = this.endPoint;\n\n        let topLeftX = Math.min(x0, x1),\n            topLeftY = Math.min(y0, y1),\n            bottomRightX = Math.max(x0, x1),\n            bottomRightY = Math.max(y0, y1);\n\n        let r1 = pixel2Point(topLeftX, topLeftY, [this.width, this.height], this.r1, this.r2);\n        let r2 = pixel2Point(bottomRightX, bottomRightY, [this.width, this.height], this.r1, this.r2);\n        this.r1 = r1;\n        this.r2 = r2;\n        this.renderMandelbrot();\n      }\n      this.startPoint = null;\n      this.endPoint = null;\n      this._dragRectContext = null;\n    },\n    onKeyPress(evt) {\n      if (evt.key == ' ' && !v_eq(this.r1, this.r2)) {\n        this.r1 = R1;\n        this.r2 = R2;\n        this.renderMandelbrot();\n      }\n    },\n    updateDragRect(startPoint, endPoint) {\n      let ctx = this._dragRectContext;\n      ctx.clearRect(0, 0, this.width, this.height);\n      if (startPoint && endPoint) {\n        let [x0, y0] = startPoint;\n        let [x1, y1] = endPoint;\n        ctx.strokeStyle = '#00ff00';\n        ctx.strokeRect(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x0 - x1), Math.abs(y0 - y1));\n      }\n    },\n    renderMandelbrot() {\n      let ctx = this.$refs.canvas.getContext('2d');\n      let t0 = performance.now();\n      let imgData = ctx.createImageData(this.width, this.height);\n      let { data } = imgData;\n      for (let i = 0; i < this.width; i++) {\n        for (let j = 0; j < this.height; j++) {\n          let p = i * 4 + j * 4 * this.width;\n          let point = pixel2Point(i, j, [this.width, this.height], this.r1, this.r2);\n          let v = escapeTime(point, ITERATIONS);\n          if (v != -1) {\n            v = 255 - v;\n          } else {\n            v = 0;\n          }\n          data[p] = v;\n          data[p + 1] = v;\n          data[p + 2] = v;\n          data[p + 3] = 255;\n        }\n      }\n\n      ctx.putImageData(imgData, 0, 0);\n      this.renderTime = performance.now() - t0;\n    },\n  }\n};\n\nfunction v_eq(v1, v2) {\n  return v1 && v2  && v1[0] == v2[0] && v1[1] == v2[1];\n}\n\nfunction pixel2Point(x, y, bounds, topLeft, bottomRight) {\n\n    let [width, height] = [bottomRight[0] - topLeft[0],\n                           topLeft[1] - bottomRight[1]];\n    return [\n      topLeft[0] + x * width / bounds[0],\n      topLeft[1] - y * height / bounds[1]\n    ];\n}\n\nfunction escapeTime(c, limit) {\n    let za = 0.0,\n      zb = 0.0;\n    for (let i = 0; i < limit; i++) {\n      let zax = za * za - zb * zb + c[0];\n      let zbx = 2 * za * zb + c[1];\n      za = zax;\n      zb = zbx;\n      if (za * za + zb * zb > 4.0) {\n        return i;\n      }\n    }\n    return -1;\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.container {\n  position: relative;\n  display: inline-block;\n  background-color: white;\n  h1 {\n    position: absolute;\n    top: 10px;\n    left: 10px;\n    z-index: 10;\n    margin: 0;\n    pointer-events: none;\n    color: #007eff;\n  }\n  canvas {\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n}\n</style>\n\n"]}]}